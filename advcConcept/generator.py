import sys


def myGenerator(n):
    for x in range(n):
        yield x**3
        
values = myGenerator(1000000)

print(f"Size of the values {sys.getsizeof(values)}")

print(next(values))
print(next(values))
print(next(values))
print(next(values))
print(next(values))
print(next(values))
print(next(values))
print(next(values))
print(next(values))
print(next(values))
print(next(values))


'''
In Python, a generator is a special type of iterator that allows you to iterate over a potentially large sequence of data 
without loading the entire sequence into memory at once. Generators are defined using a function with the `yield` statement. When a generator function is called, 
it returns a generator object, which can be iterated over to produce values one at a time.

Here's a simple example of a generator function:

```python
def simple_generator():
    yield 1
    yield 2
    yield 3

# Using the generator
my_generator = simple_generator()

for value in my_generator:
    print(value)
```

When you run this code, it will output:

```
1
2
3
```

Each time the `yield` statement is encountered in the generator function, the function's state is saved, and the yielded value is returned. 
The next time the generator is iterated, it resumes execution from where it was paused, using the saved state.

Generators are useful in situations where you have a large dataset or when you want to generate values on-the-fly without precomputing them. 
They are memory-efficient because they produce values one at a time, as opposed to creating a list or other data structure to store all values at once.

Here's an example of a generator that generates Fibonacci numbers up to a specified limit:

```python
def fibonacci_generator(limit):
    a, b = 0, 1
    while a < limit:
        yield a
        a, b = b, a + b

# Using the generator
fibonacci_numbers = fibonacci_generator(50)

for num in fibonacci_numbers:
    print(num)
```

This generator will produce Fibonacci numbers until the value exceeds the specified limit.



In Python, the `yield` keyword is used in the context of generator functions to produce a sequence of values. 
When a function containing `yield` is called, it returns a generator object, which can be iterated over to retrieve the values generated by the function one at a time.

Here's a basic example to illustrate the use of `yield`:

```python
def simple_generator():
    yield 1
    yield 2
    yield 3

# Using the generator
my_generator = simple_generator()

for value in my_generator:
    print(value)
```

In this example, the `simple_generator` function contains three `yield` statements. When the generator is iterated, the function starts executing 
until it encounters the first `yield` statement, at which point it produces the value (`1` in this case) and pauses. 
The generator retains its state, allowing it to resume execution from where it left off when it's iterated again.

So, when you run the code above, it prints:

```
1
2
3
```

The key characteristics of `yield` in Python are:

1. **Suspends Execution:** When a `yield` statement is encountered, the function's state is saved, and the yielded value is returned. The function is paused at this point.

2. **State Retention:** The generator retains its state, allowing it to resume execution from where it was paused when iterated again.

3. **Iteration:** The generator can be iterated using a `for` loop or other iteration mechanisms, producing values one at a time.

4. **Memory Efficiency:** Generators are memory-efficient because they generate values on-the-fly, avoiding the need to store the entire sequence in memory.

Generators are commonly used when dealing with large datasets, streaming data, or situations where you want to generate values lazily rather than all at once.

'''